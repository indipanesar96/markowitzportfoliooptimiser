\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{float}
\geometry{legalpaper, portrait, margin=1.5in}
\usepackage{amsmath}
\title{Computational Finance with C++}
\author{CID: 01805027}
\date{10 June 2020}
\usepackage[thinc]{esdiff}
\usepackage{hyperref}
\begin{document}
\renewcommand*{\arraystretch}{1.5}

\maketitle
\section{Introduction} 
\label{sec:introduction}

Since their inception, economists, mathematicians, physicists and computer scientists the like have sought to 'beat' the markets using developments in their respective fields.


maybe capm doesnt need to be mentioned? capm states investors and mean varianceefficient optimisers, and so efficient frontier must've come first

A long-standing theory of the markets is the Capital Asset Pricing Model (CAPM) which states that a market participant may be rewarded with returns above the market rate proportionate to the amount of risk taken on. This gave rise 



MENTION CAPM BUTCAPM SAYS YOURE REWARDED PROPORTIONAL TO HOW MUCH NON-DIVERSIFIABLE RISK YOU TAKE ON, oN THE FRONTIER GRAPH WE LOOK AT ALL THE VARIANCE ASSOCIATED WITH THE STOCK (DIVERSIFIABLE AND NOT)



\subsection{Theory}
\label{sec:theory}

As aforementioned, we employ Lagrange Multipliers to constrain the portfolio problem, allowing us to adhere to real-world constraints whilst also seeking to minimise the variance of the portfolio.

In Equation (\ref{portfolio_variance}), we define the variance of the Markowitz portfolio, $\sigma_{p}^{2}$, with a preceding factor of $\frac{1}{2}$ for convenience. $w_i$ is the weight of asset $i$ in the portfolio and $\sigma_{ij}$ is the covariance between stocks $i$ and $j$.

\begin{equation}
\dfrac{1}{2} \sigma^{2}_{p} =  \dfrac{1}{2} \sum_{i,j=1}^{n} w_{i} \sigma_{ij} w_{j}
\label{portfolio_variance}
\end{equation}

The variance of the portfolio is minimised via the Lagrange method while ensuring the following two constraints are also upheld. 

\begin{equation}
\sum_{i=1}^{n} w_{i} \overline{r_i} - \overline{r_p} = 0
\label{target_return_constraint}
\end{equation}

Above, we mandate that the portfolio return is equal to the value $r_p$. By setting $r_p$, we may effectively 'choose' the portfolio return we desire and thus the weights the optimisation method yields.

Below, is simple the constraint that the sum of the portfolio weights must be equal to unity. This ensures that we do not over or under-allocate the funds available to us.

\begin{equation} 
\sum_{i=1}^{n} w_{i} - 1 = 0
\label{weights_constraint}
\end{equation}

\begin{equation} 
L(w, \lambda, \mu) =  \dfrac{1}{2} \sum_{i,j=1}^{n} w_{i} \sigma_{ij} w_{j} 
	-\lambda \left( \sum_{i=1}^{n} w_{i} \overline{r_i} - \overline{r_p}) \right)
	- \mu \left( \sum_{i=1}^{n} w_{i} - 1 \right)
\label{lagrangian}
\end{equation}

Finally, Equation(\ref{lagrangian}) shows the Lagrangian we seek to minimise. 

For convenience when scaling to a large number of assets and to code in the possibility of introducing further constraints, we introduce the following matrix notation:

\begin{description}
\item [$\bullet$ $\emph{w} = (w_1,..., w_n) \in \Re^n$ ] - a vector of $n$ weights for $n$ assets
\item [$\bullet$ $\overline{\emph{r}} = (\overline{r_1},..., \overline{r_n}) \in \Re^n$ ] - a vector of $n$ expected asset returns
\item [$\bullet$ $\emph{1} = (1,..., 1) \in \Re^n$ ] - the unit vector $n$
\item [$\bullet$ $\emph{0} = (0,..., 0) \in \Re^n$ ] - the zero vector of length $n$
\end{description}

The Lagrangian in matrix form is shown below in Equation (\ref{vector_lagrangrian}) where $\Sigma \in \Re^{n \times n}$ is the covariance matrix of the assets, explicitly; $\Sigma_{ij} = \sigma_{ij}$ as defined above.

\begin{equation} 
L(\textbf{w}, \lambda, \mu)  = \dfrac{1}{2} \textbf{w}'\Sigma\textbf{w}
-\lambda \left( \textbf{w}'\overline{\textbf{r}} - \overline{r_p}\right)
-\mu \left( \textbf{w}'\textbf{e} - 1\right)
\label{vector_lagrangrian}
\end{equation}

Now, in order to minimise the Lagrangian it must be differentiated with respect to the weights, {\textbf{w}}. Allowing us to find the rate of change of the system's Lagrangian with respect to the portfolio weights themselves and setting the resulting equation to zero will give us the turning point of the function.

\begin{equation}
\diff{L(\textbf{w}, \lambda, \mu)}{\textbf{w}'} =  \Sigma\textbf{w}
-\lambda \overline{\textbf{r}}
-\mu\textbf{e} = 0
\label{optimality_lagrangian}
\end{equation}

It may be seen by inspection that the second derivative of the Lagrangian with respect to $\textbf{w}$  is indeed positive for all values of $\textbf{w}$ meaning that this is indeed a minimum and that the function itself is concave.

With Equations (\ref{target_return_constraint}) and (\ref{weights_constraint}) also required for optimality, we may write the system of $n+2$ equations as a single matrix equation written in the form $Ax = b$, below in Equation (\ref{matrix_eqn}). $A$ is an $n+2$ square matrix and the two column vectors both have dimensions $(n+2) \times 1$ respectively. Later we seek to solve this numerically via the Quadratic Conjugate Method to find the vector of weights $w$ that yield the desired portfolio return, $r_p$, the solution to Equation (\ref{matrix_solved}).

\begin{equation}
\begin{bmatrix}
\Sigma & -\overline{\textbf{r}} & -\textbf{e} \\
-\overline{\textbf{r}}'  & 0 & 0 \\
-\textbf{e}' & 0 & 0 
\end{bmatrix}
\begin{bmatrix}
\textbf{w}\\
\lambda \\
\mu
\end{bmatrix}
=
\begin{bmatrix}
\textbf{0}\\
-\overline{r_p}\\
-1
\end{bmatrix}
\label{matrix_eqn}
\end{equation}


\begin{equation}
\begin{bmatrix}
\textbf{w}\\
\lambda \\
\mu
\end{bmatrix}
=
\begin{bmatrix}
\Sigma & -\overline{\textbf{r}} & -\textbf{e} \\
-\overline{\textbf{r}}'  & 0 & 0 \\
-\textbf{e}' & 0 & 0 
\end{bmatrix}^{-1}
\begin{bmatrix}
\textbf{0}\\
-\overline{r_p}\\
-1
\end{bmatrix}
\label{matrix_solved}
\end{equation}


\section{Implementation}
\label{sec:implementation}

\subsection{Code}
\label{sec:implementation_code}


With a distinct focus on code readability, maintainability and efficiency, the backtesting frameworks, Quadratic Conjugate Method and other necessary tools to backtest the Markowitz optimised portfolio were written in C++ (which may be seen explicitly in \hyperref[sec:code]{code subsection} of the \hyperref[sec:appendix]{Appendix}).


The project code was split into five distinct project directories for the easy of maintenance and cleanliness. The directories and their contents are outlined briefly for context in the following sections.

\subsubsection{Utility}
\label{sec:utility}

The Utility contained the classes and structs \textit{VectorUtil, Matrix, RunConfig} and \textit{Results}. 
The first two contained small building-block-esque functions upon which the entirety of the application is based. As such, it was vital that these methods used to perform arithmetic operations on vectors and matrices were well tested and efficient.

\textit{RunConfig}  and \textit{Results} are both C++ structs used to group pieces of information in a convenient manor. The former contained parameters that were pertinent to a particular run of the backtest. It was useful to run the application on small and medium sized subsets of the data for debugging purposes and so with each of these came a set of parameters (in/out of sample window lengths, for example) that were specific to the dataset in question. It became cleaner and more convenient to group these parameters together into one object (a \textit{RunConfig} struct) and pass this to \textit{Portfolio::backtest()}.  
The same philosophy was behind the use of the \textit{Results} struct as a return type from the aforementioned portfolio method as a way to group multiple result outputs together, instead of passing each object by reference or pointer individually. 

I found this line of reasoning to be especially pertinent with method signatures since their readability contributes massively to the readability of the application as a whole.  


\subsubsection{Data Repository}
\label{sec:data_repository}


\subsubsection{Parameter Estimation}
\label{sec:parameter_estimation}


\subsubsection{Portfolio}
\label{sec:portfolio}


\subsubsection{Backtest}
\label{sec:backtestcode}





\begin{description}
	\item [$\bullet$ \textbf{Backtest}] 
	\item [$\bullet$ \textbf{Parameter Estimation}] 
	\item [$\bullet$ \textbf{Portfolio}] 
	\item [$\bullet$ \textbf{Data Repository}] 
	\item [$\bullet$ \textbf{Utility}] 	
\end{description}



\subsection{Quadratic Conjugate Method}
\label{sec:qcm}


\section{Results \& Discussion}
\label{sec:results}


\section{Conclusions}
\label{sec:concs}



\begin{thebibliography}{}
\label{sec:thebibliography}
	\bibitem{pwatson} Watson, P. (2005). Ideas: A History of Thought and Invention from Fire to Freud. New York: HarperCollins Publishers.
	
	
\end{thebibliography} 



\section{Appendix} 
\label{sec:appendix}

subsection{Code} 
\label{sec:code}


\end{document}